# Dynamic Malware Analysis

**`Author:`** Res260#1617

## Description


### Flag 1: Dynamic Malware Analysis 1: Proxy address

Track by `Res260#1617`

Intro: Sure, binary reverse engineering is great, but have you ever
found a C2 from a well-obfuscated malware without having to
read soul-crushing x86-64 instructions? Sometimes, simple dynamic analysis
techniques will yield results way faster when analysing a malware, leaving
more precious time to focus doing important stuff during an incident response.

Here is a malware we found on an employee's computer. Our
Cyber Threat Intelligence (CTI) team believes it comes from *Alchemist Rat*,
a threat actor group that specifically targets our company. We have not 
been able to identify the Command and Control (C2) Server for this
malware. Please help us.

-----

The malware communicates over HTTP, using a hardcoded proxy.
What is the proxy the malware uses? It is recommended to solve this
challenge with procmon or wireshark.
**Format: `{ip}:{port}`**

Note: This is **not** a binary reverse engineering challenge.
You should not have/want to solve this challenge by reversing 
the malware (even if technically possible), but instead by running
it in a controlled environment. This malware is safe to run on your
personnal machine, but it is good practice to have a separate
environment (such as Virtual Machines) specifically made to run 
untrusted executables. An easy way to do that with Windows is using
[Windows Sandbox](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview).

*Note: This challenge is inspired by a real malware that was analyzed by 
Desjardins' security team during an incident response investigation, using 
similar techniques.*

Flag: `127.0.0.1:8080`

### Flag 2: Dynamic Malware Analysis 2: First connection test
Before reaching to it's real C2 domain, 
the malware tests that internet connectivity 
works by reaching out to a known Website (to 
prevent sandboxes to extract the C2 easily).
What is the URI (the part after the domain name,
including the first `/`) of the first request?

It is recommended to solve this challenge with mitmproxy

**Format: `/something`**

Flag: `/f60f9bb7f0fa90913ed00422bdc5bc963024003a8a7b09d2322567159a07fcd8`

### Flag 3: Dynamic Malware Analysis 3: HTTPS connection test.

The malware then does a call to the same domain,
but with a different URI and using HTTPS. What
is this new URI?

Note: The malware checks that the certificate is trusted by the machine.

**Format: `/something`**

Flag: `/9ba5e93514b36b13d4d97d3dea0067b043bd4d97d3dea0067b043bd4d97d3dea0067b043bd4d97d3dea0067b043b`


### Flag 4: C2 Domain

What is the C2 Domain?

Format: `domain-name.something`

Flag: `totallylegitdomain-notevil.cn`

### Flag 5: Dynamic Malware Analysis 4: C2 Handshake

Solving the last challenge should reveal the real C2 behind this
malware. However, before actually sending information to the server,
a handshake is done to ensure the server is legitimate. Our CTI team
told us that usually, the server needs to respond with the following content: `None`.
Then, legend says the malware spits out a flag...

Note: If you enjoy this kind of challenges, you might enjoy
interning or working at Desjardins! We have a *lot* of different
security teams that tackle difficult problems. [Details here](https://ctf.unitedctf.ca/desjardins).

**Flag format: `FLAG-[a-z0-9]+`**

Flag: `FLAG-6588ba4c1b32f4f2dc5c0a500311153da500311153dd981841c`


## Files

malware.exe

## Solution

## Flag 1: 

1. Download procmon64.exe from https://live.sysinternals.com/
2. Launch procmon64.exe
3. Add a filter: Process Name contains <nameofmalware>.exe
4. Only "show network activity"
5. Launch the malware
6. See it's localhost:8080
7. Flag: `127.0.0.1:8080`

## Flag 2

1. Install mitmproxy
2. Launch mitmweb: `C:\Program Files\mitmproxy\bin\mitmweb.exe`
3. Execute the malware
4. Look at the request in mitmweb for google.ca and note the URI
5. Flag: `/f60f9bb7f0fa90913ed00422bdc5bc963024003a8a7b09dd8`

## Flag 3
1. In mitmweb, get the certificate: Set your windows proxy to
`http://127.0.0.1:8080` in the "proxy settings" then save
2. In mitmweb: File --> install certificates --> follow instructions
3. If that doesnt work, download cert using this powershell command: `curl http://mitm.it/cert/p12 -UseBasicParsing -Proxy http://127.0.01:8080 -OutFile out.p12`
4. Install the cert in the "Trusted Root Certification Authorities" store.
5. Execute the malware
6. See the https request in mitmweb
7. Flag: `/9ba5e93514b36b13d4d97d3dea0067b043bd4d97d3dea0067b043bd4d97d3dea0067b043bd4d97d3dea0067b043b`

## Flag 4

1. Install wireshark
2. Start a packet capture with all the interfaces listening
3. Filter packets: `http`
4. Execute the malware
5. The last packets should show the C2 Domain
6. Flag: `totallylegitdomain-notevil.cn`


# Flag 5:
1. Add this line to your `C:\Windows\System32\Drivers\etc\hosts` file: `127.0.0.1 totallylegitdomain-notevil.cn`. This ensures requests to the C2 domain will be redirected on the machine.
2. In the mitmweb interface, options --> check `Don't verify server certificates`
3. Generate a self-signed cert for the C2 domain `totallylegitdomain-notevil.cn` here: https://regery.com/en/security/ssl-tools/self-signed-certificate-generator
4. Download the cert and the private key
5. Create an HTTPS web server using python. Example: the `simple_webserver.py` file in this repo.
6. Launch the webserver: `python simple_webserver.py`
7. Execute the malware
8. Look in mitmweb, and see that the requested URI is `/handshaketest`
9. Create a file named `handshaketest` in the same directory with the content: `None`
10. Execute the malware again
11. Look in mitmweb, you should see the flag!
12. Flag: `FLAG-6588ba4c1b32f4f2dc5c0a500311153da500311153dd981841c`



-----

Build the .exe:
1. Install dependencies: `pip install -r requirements.txt`
2. Change `pip_system_certs.wrapt_requests`... Need to swap the two functions of place, else it doesnt work compiled... 
3. Compile with nuitka: `python -m nuitka .\main.py --onefile`
